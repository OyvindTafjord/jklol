package com.jayantkrish.jklol.preprocessing;

import java.util.Arrays;
import java.util.Map;

import com.jayantkrish.jklol.util.CountAccumulator;

/**
 * Utilities for manipulating {@link FeatureGenerator}s.
 * 
 * @author jayantk
 */
public class FeatureGenerators {

  /**
   * Combines many {@code FeatureGenerator}s into a single
   * {@code FeatureGenerator}. The returned generator returns the union of all
   * features generated by {@code generators}. If multiple generators output
   * the same feature, the returned generator sums their counts.
   */
  public static <A, B> FeatureGenerator<A, B> combinedFeatureGenerator(
      Iterable<FeatureGenerator<A, ? extends B>> generators) {
    return new CombinedFeatureGenerator<A, B>(generators);
  }
  
  /**
   * See {@link #combinedFeatureGenerator(Iterable)}.
   * @param generators
   * @return
   */
  public static <A, B> FeatureGenerator<A, B> combinedFeatureGenerator(
      FeatureGenerator<A, ? extends B> ... generators) {
    return FeatureGenerators.combinedFeatureGenerator(Arrays.asList(generators));
  }

  /**
   * Combines many {@code FeatureGenerator}s into a single
   * {@code FeatureGenerator} which returns the sum of each base generator's
   * feature counts.
   * 
   * @author jayantk
   * @param <A>
   * @param <B>
   */
  private static class CombinedFeatureGenerator<A, B> implements FeatureGenerator<A, B> {

    private Iterable<FeatureGenerator<A, ? extends B>> generators;
    
    public CombinedFeatureGenerator(Iterable<FeatureGenerator<A, ? extends B>> generators) {
      this.generators = generators;
    }

    @Override
    public Map<B, Double> generateFeatures(A item) {
      CountAccumulator<B> featureCounts = CountAccumulator.create();
      for (FeatureGenerator<A, ? extends B> generator : generators) {
        featureCounts.increment(generator.generateFeatures(item));
      }
      return featureCounts.getCountMap();
    }
  }
}
