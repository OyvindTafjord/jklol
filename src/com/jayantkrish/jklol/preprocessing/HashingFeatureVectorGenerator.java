package com.jayantkrish.jklol.preprocessing;

import java.util.Map;

import com.google.common.base.Preconditions;
import com.jayantkrish.jklol.tensor.SparseTensorBuilder;
import com.jayantkrish.jklol.tensor.Tensor;

/**
 * Hashes the features generated by a {@code FeatureGenerator} into a
 * fixed-dimensionality feature vector. This hashing process may cause feature
 * collisions, where multiple generated features map to the same index in the
 * feature vector. However, hashing features uses less memory than a feature
 * dictionary, and can be faster. It also doesn't require a priori enumeration
 * of the set of possible features.
 * 
 * @author jayantk
 * @param <T>
 */
public class HashingFeatureVectorGenerator<T> implements FeatureVectorGenerator<T> {

  private final int dimension;
  private final FeatureGenerator<T, ? extends Object> featureGenerator;
  
  public HashingFeatureVectorGenerator(int dimension, 
      FeatureGenerator<T, ? extends Object> featureGenerator) {
    this.dimension = dimension;
    this.featureGenerator = Preconditions.checkNotNull(featureGenerator);
  }

  @Override
  public Tensor apply(T item) {
    Map<? extends Object, Double> features = featureGenerator.generateFeatures(item);
    SparseTensorBuilder featureBuilder = new SparseTensorBuilder(new int[] {0}, new int[] {dimension});
    for (Map.Entry<? extends Object, Double> entry : features.entrySet()) {
      featureBuilder.incrementEntry(entry.getValue(), getFeatureIndex(entry.getKey()));
    }
    return featureBuilder.build();
  }
  
  private int getFeatureIndex(Object obj) {
    return Math.abs(obj.hashCode()) % dimension;
  }

  @Override
  public int getNumberOfFeatures() {
    return dimension;
  }
}
